<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRSP Relay Playground</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        mono: ['JetBrains Mono', 'monospace']
                    }
                }
            }
        }
    </script>
    <style>
        :root { color-scheme: dark; }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden bg-black text-white font-mono antialiased">

<!-- TOP HEADER -->
<header class="h-12 border-b border-neutral-800 bg-black flex items-center justify-between px-6 shrink-0">
    <h1 class="text-sm font-bold tracking-wider">
        CRSP<span class="text-neutral-400">PLAYGROUND</span>
    </h1>
    <div class="text-xs text-neutral-400 uppercase tracking-wider">Content Relay Sync Protocol</div>
</header>

<!-- MAIN WORKSPACE -->
<div class="flex-1 flex overflow-hidden">

    <!-- LEFT SIDEBAR -->
    <aside class="w-96 bg-black border-r border-neutral-800 flex flex-col shrink-0 overflow-y-auto">

        <!-- Connection Section -->
        <section class="p-5 border-b border-neutral-800">
            <h2 class="text-xs text-neutral-400 uppercase tracking-wider mb-3 font-semibold">Connection</h2>
            <div class="space-y-2.5">
                <input id="serverUrl" type="text" value="ws://localhost:3000" placeholder="Server URL"
                       class="w-full px-3 py-2 bg-neutral-950 border border-neutral-800 rounded text-sm placeholder:text-neutral-500 focus:outline-none focus:border-neutral-700 focus:bg-neutral-900 transition-all">
                <input id="sessionId" type="text" placeholder="Session ID" maxlength="8" value="TEST1234"
                       class="w-full px-3 py-2 bg-neutral-950 border border-neutral-800 rounded text-sm placeholder:text-neutral-500 focus:outline-none focus:border-neutral-700 focus:bg-neutral-900 transition-all uppercase">
                <input id="connectionId" type="text" placeholder="Connection ID" value="dev-1"
                       class="w-full px-3 py-2 bg-neutral-950 border border-neutral-800 rounded text-sm placeholder:text-neutral-500 focus:outline-none focus:border-neutral-700 focus:bg-neutral-900 transition-all">
                <input id="secret" type="text" placeholder="Secret" value="dev-secret-key-2025"
                       class="w-full px-3 py-2 bg-neutral-950 border border-neutral-800 rounded text-sm placeholder:text-neutral-500 focus:outline-none focus:border-neutral-700 focus:bg-neutral-900 transition-all">
                <button id="connectBtn"
                        class="w-full px-3 py-2 rounded text-sm font-semibold transition-all bg-white text-black border border-white hover:bg-neutral-200 mt-1">
                    Connect
                </button>
            </div>
        </section>

        <!-- Status Section -->
        <section class="p-5 border-b border-neutral-800">
            <h2 class="text-xs text-neutral-400 uppercase tracking-wider mb-3 font-semibold">Status</h2>
            <dl class="bg-neutral-950 border border-neutral-800 rounded p-3 space-y-2.5">
                <div class="flex items-center justify-between">
                    <dt class="text-neutral-300 text-sm">Connection</dt>
                    <dd id="statusConnection" class="font-medium text-neutral-500 text-sm">Disconnected</dd>
                </div>
                <div class="flex items-center justify-between">
                    <dt class="text-neutral-300 text-sm">Session</dt>
                    <dd id="statusSession" class="font-medium text-neutral-500 text-sm">-</dd>
                </div>
                <div class="flex items-center justify-between">
                    <dt class="text-neutral-300 text-sm">Connection ID</dt>
                    <dd id="statusConnectionId" class="font-medium text-neutral-500 text-sm">-</dd>
                </div>
                <div class="flex items-center justify-between">
                    <dt class="text-neutral-300 text-sm">Other Connection</dt>
                    <dd id="statusOtherConnection" class="font-medium text-neutral-500 text-sm">-</dd>
                </div>
            </dl>
        </section>

        <!-- Connection Info Section -->
        <section class="p-5 flex-1">
            <h2 class="text-xs text-neutral-400 uppercase tracking-wider mb-3 font-semibold">Connection Info</h2>
            <dl class="bg-neutral-950 border border-neutral-800 rounded p-3 space-y-3">
                <div class="flex items-center justify-between">
                    <dt class="text-neutral-400 text-sm">Connected</dt>
                    <dd id="infoConnectedTime" class="font-medium text-neutral-500 text-sm">-</dd>
                </div>
                <div class="flex items-center justify-between">
                    <dt class="text-neutral-400 text-sm">Messages Sent</dt>
                    <dd id="infoMessagesSent" class="font-medium text-neutral-500 text-sm">0</dd>
                </div>
                <div class="flex items-center justify-between">
                    <dt class="text-neutral-400 text-sm">Messages Received</dt>
                    <dd id="infoMessagesReceived" class="font-medium text-neutral-500 text-sm">0</dd>
                </div>
                <div class="flex items-center justify-between">
                    <dt class="text-neutral-400 text-sm">Bytes Sent</dt>
                    <dd id="infoBytesSent" class="font-medium text-neutral-500 text-sm">0 B</dd>
                </div>
                <div class="flex items-center justify-between">
                    <dt class="text-neutral-400 text-sm">Bytes Received</dt>
                    <dd id="infoBytesReceived" class="font-medium text-neutral-500 text-sm">0 B</dd>
                </div>
            </dl>
        </section>
    </aside>

    <!-- CENTER: Console -->
    <main class="flex-1 flex flex-col bg-neutral-950 min-w-0">
        <div class="h-10 border-b border-neutral-800 flex items-center justify-between px-5 bg-black">
            <h2 class="text-xs font-semibold text-neutral-400 uppercase tracking-wider">Console Output</h2>
            <div class="flex items-center gap-4">
                <label class="flex items-center gap-1.5 cursor-pointer">
                    <input id="autoscroll" type="checkbox" checked class="w-3 h-3 accent-white">
                    <span class="text-xs text-neutral-400">Autoscroll</span>
                </label>
                <button id="clearBtn" class="text-xs text-neutral-400 hover:text-white transition-colors uppercase tracking-wider">
                    Clear
                </button>
            </div>
        </div>
        <div id="console" class="flex-1 overflow-y-auto p-5 space-y-1.5 leading-tight select-text"></div>
    </main>

    <!-- RIGHT SIDEBAR -->
    <aside class="w-[448px] bg-black border-l border-neutral-800 flex flex-col shrink-0">
        <div class="p-5 flex-1 flex flex-col">
            <h2 class="text-xs text-neutral-400 uppercase tracking-wider mb-3 font-semibold">Send Message</h2>
            <div class="space-y-2.5 flex-1 flex flex-col">
                <select id="contentType"
                        class="w-full px-3 py-2 bg-neutral-950 border border-neutral-800 rounded text-sm focus:outline-none focus:border-neutral-700 cursor-pointer">
                    <option value="text">Text</option>
                    <option value="binary">Binary (base64)</option>
                </select>

                <!-- Metadata Section -->
                <div class="space-y-2">
                    <div class="flex items-center justify-between">
                        <span class="text-xs text-neutral-400 uppercase tracking-wider font-semibold">Metadata</span>
                        <label class="flex items-center gap-1.5 cursor-pointer">
                            <input id="metadataJsonToggle" type="checkbox" class="w-3 h-3 accent-white">
                            <span class="text-xs text-neutral-400">JSON</span>
                        </label>
                    </div>

                    <!-- Key-Value Mode -->
                    <div id="metadataKeyValueSection" class="space-y-2">
                        <div class="flex gap-2">
                            <input id="metadataKey" type="text" placeholder="Key"
                                   class="flex-1 min-w-0 px-3 py-2 bg-neutral-950 border border-neutral-800 rounded text-sm placeholder:text-neutral-500 focus:outline-none focus:border-neutral-700 focus:bg-neutral-900 transition-all">
                            <input id="metadataValue" type="text" placeholder="Value"
                                   class="flex-1 min-w-0 px-3 py-2 bg-neutral-950 border border-neutral-800 rounded text-sm placeholder:text-neutral-500 focus:outline-none focus:border-neutral-700 focus:bg-neutral-900 transition-all">
                        </div>
                        <button id="metadataAddBtn" type="button" disabled
                                class="w-full px-3 py-2 rounded text-sm font-semibold transition-all bg-white text-black border border-white hover:bg-neutral-200 disabled:bg-neutral-800 disabled:text-neutral-500 disabled:border-neutral-800 disabled:cursor-not-allowed">
                            Add
                        </button>
                        <div id="metadataList" class="space-y-1 max-h-32 overflow-y-auto"></div>
                    </div>

                    <!-- JSON Mode -->
                    <div id="metadataJsonSection" class="hidden">
                        <textarea id="messageMetadata" placeholder='{"key": "value"}'
                                  spellcheck="false"
                                  rows="3"
                                  class="w-full px-3 py-2 bg-neutral-950 border border-neutral-800 rounded text-sm placeholder:text-neutral-500 focus:outline-none focus:border-neutral-700 focus:bg-neutral-900 transition-all resize-none leading-relaxed"></textarea>
                    </div>
                </div>

                <textarea id="messageData" placeholder="Type a message... (Enter to send, Shift+Enter for new line)"
                          spellcheck="false"
                          class="flex-1 w-full px-3 py-2 bg-neutral-950 border border-neutral-800 rounded text-sm placeholder:text-neutral-500 focus:outline-none focus:border-neutral-700 focus:bg-neutral-900 transition-all resize-none leading-relaxed"></textarea>
                <button id="sendBtn" disabled
                        class="w-full px-3 py-2 rounded text-sm font-semibold transition-all bg-white text-black border border-white hover:bg-neutral-200 disabled:bg-neutral-800 disabled:text-neutral-500 disabled:border-neutral-800 disabled:cursor-not-allowed">
                    Send
                </button>
            </div>
        </div>
    </aside>
</div>

<script>
    // ============================================================================
    // CONFIGURATION
    // ============================================================================
    const CONFIG = {
        SESSION_ID_PATTERN: /^[a-zA-Z0-9]{8}$/,
        TIME_FORMAT: { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 },
        WS_CLOSE_NORMAL: 1000
    };

    // Badge styles using Tailwind classes only
    const BADGE_STYLES = {
        ready:   { bg: 'bg-blue-500/15',    text: 'text-blue-400',    border: 'border-blue-500/30' },
        connection: { bg: 'bg-violet-500/15',  text: 'text-violet-400',  border: 'border-violet-500/30' },
        error:   { bg: 'bg-red-500/15',     text: 'text-red-400',     border: 'border-red-500/30' },
        data:    { bg: 'bg-green-500/15',   text: 'text-green-400',   border: 'border-green-500/30' },
        ack:     { bg: 'bg-teal-500/15',    text: 'text-teal-400',    border: 'border-teal-500/30' },
        control: { bg: 'bg-yellow-500/15',  text: 'text-yellow-400',  border: 'border-yellow-500/30' },
        client:  { bg: 'bg-neutral-500/15', text: 'text-neutral-400', border: 'border-neutral-500/30' }
    };

    // Direction indicators for log entries
    const DIRECTION_CONFIG = {
        in:     { symbol: '←', color: 'text-emerald-500' },
        out:    { symbol: '→', color: 'text-blue-500' },
        server: { symbol: '◆', color: 'text-violet-400' }
    };

    // Message types that come from server
    const SERVER_MESSAGE_TYPES = ['ready', 'connection', 'error'];

    // ============================================================================
    // DOM UTILITIES
    // ============================================================================
    const $ = (id) => document.getElementById(id);

    const dom = {
        serverUrl: $('serverUrl'),
        sessionId: $('sessionId'),
        connectionId: $('connectionId'),
        secret: $('secret'),
        connectBtn: $('connectBtn'),
        statusConnection: $('statusConnection'),
        statusSession: $('statusSession'),
        statusConnectionId: $('statusConnectionId'),
        statusOtherConnection: $('statusOtherConnection'),
        console: $('console'),
        autoscroll: $('autoscroll'),
        clearBtn: $('clearBtn'),
        infoConnectedTime: $('infoConnectedTime'),
        infoMessagesSent: $('infoMessagesSent'),
        infoMessagesReceived: $('infoMessagesReceived'),
        infoBytesSent: $('infoBytesSent'),
        infoBytesReceived: $('infoBytesReceived'),
        contentType: $('contentType'),
        metadataJsonToggle: $('metadataJsonToggle'),
        metadataKeyValueSection: $('metadataKeyValueSection'),
        metadataJsonSection: $('metadataJsonSection'),
        metadataKey: $('metadataKey'),
        metadataValue: $('metadataValue'),
        metadataAddBtn: $('metadataAddBtn'),
        metadataList: $('metadataList'),
        messageMetadata: $('messageMetadata'),
        messageData: $('messageData'),
        sendBtn: $('sendBtn')
    };

    /** Updates element text and color in one call */
    function setElementState(el, text, colorClass = 'text-neutral-500') {
        el.textContent = text;
        el.className = `font-medium text-sm ${colorClass}`;
    }

    /** Resets element to default empty state */
    function resetElement(el) {
        setElementState(el, '-');
    }

    // ============================================================================
    // FORMAT UTILITIES
    // ============================================================================
    function formatBytes(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return `${parseFloat((bytes / k ** i).toFixed(1))} ${sizes[i]}`;
    }

    function formatDuration(ms) {
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);

        if (hours > 0) return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
        if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
        return `${seconds}s`;
    }

    function formatTimestamp() {
        return new Date().toLocaleTimeString('en-US', CONFIG.TIME_FORMAT);
    }

    // ============================================================================
    // STATE MANAGEMENT
    // ============================================================================
    const state = {
        ws: null,
        connected: false,
        sessionId: null,
        connectionId: null,
        otherConnection: null,
        metadataEntries: [],
        stats: createEmptyStats(),
        timerId: null
    };

    function createEmptyStats() {
        return {
            connectedAt: null,
            messagesSent: 0,
            messagesReceived: 0,
            bytesSent: 0,
            bytesReceived: 0
        };
    }

    function resetState() {
        Object.assign(state, {
            connected: false,
            sessionId: null,
            connectionId: null,
            otherConnection: null,
            metadataEntries: [],
            stats: createEmptyStats()
        });

        if (state.timerId) {
            clearInterval(state.timerId);
            state.timerId = null;
        }
    }

    function trackMessage(direction, bytes) {
        if (direction === 'sent') {
            state.stats.messagesSent++;
            state.stats.bytesSent += bytes;
        } else {
            state.stats.messagesReceived++;
            state.stats.bytesReceived += bytes;
        }
        updateStatsUI();
    }

    // ============================================================================
    // LOGGING SYSTEM
    // ============================================================================
    function createLogBadge(type) {
        const style = BADGE_STYLES[type] || BADGE_STYLES.client;
        const span = document.createElement('span');
        span.className = `inline-flex items-center px-1.5 py-0.5 rounded text-[10px] font-semibold uppercase tracking-wide border ${style.bg} ${style.text} ${style.border}`;
        span.textContent = type.toUpperCase();
        return span;
    }

    function createDirectionIndicator(direction, type) {
        const span = document.createElement('span');
        span.className = 'w-4 text-center shrink-0';

        const dirKey = direction || (SERVER_MESSAGE_TYPES.includes(type) ? 'server' : null);
        const config = DIRECTION_CONFIG[dirKey];

        if (config) {
            span.className += ` ${config.color}`;
            span.textContent = config.symbol;
        }

        return span;
    }

    function truncateLargeValues(obj, maxLength = 1000) {
        if (typeof obj !== 'object' || obj === null) {
            return obj;
        }

        if (Array.isArray(obj)) {
            return obj.map(item => truncateLargeValues(item, maxLength));
        }

        const result = {};
        for (const [key, value] of Object.entries(obj)) {
            if (key === 'data' && typeof value === 'string' && value.length > maxLength) {
                result[key] = value.substring(0, maxLength) + `... [truncated ${value.length - maxLength} chars]`;
            } else if (typeof value === 'object' && value !== null) {
                result[key] = truncateLargeValues(value, maxLength);
            } else {
                result[key] = value;
            }
        }
        return result;
    }

    function createLogEntry(type, message, direction, data) {
        const entry = document.createElement('div');
        entry.className = 'hover:bg-neutral-900/50 -mx-2 px-2 py-1 rounded transition-colors';

        // Main row
        const row = document.createElement('div');
        row.className = 'flex items-start gap-2';

        // Timestamp
        const timestamp = document.createElement('span');
        timestamp.className = 'text-neutral-500 text-xs shrink-0 pt-0.5 tabular-nums';
        timestamp.textContent = `[${formatTimestamp()}]`;

        // Message text
        const msg = document.createElement('span');
        msg.className = 'text-neutral-300 text-sm flex-1';
        msg.textContent = message;

        row.append(timestamp, createDirectionIndicator(direction, type), createLogBadge(type), msg);
        entry.appendChild(row);

        // Optional data payload
        if (data) {
            const dataDiv = document.createElement('div');
            dataDiv.className = 'ml-32 text-xs text-neutral-500 bg-neutral-900/50 border border-neutral-800 rounded p-2 mt-1 font-mono overflow-x-auto whitespace-pre';
            dataDiv.textContent = JSON.stringify(truncateLargeValues(data), null, 2);
            entry.appendChild(dataDiv);
        }

        return entry;
    }

    function log(type, message, direction = null, data = null) {
        dom.console.appendChild(createLogEntry(type, message, direction, data));

        if (dom.autoscroll.checked) {
            dom.console.scrollTop = dom.console.scrollHeight;
        }
    }

    // ============================================================================
    // UI UPDATE FUNCTIONS
    // ============================================================================
    function updateStatsUI() {
        const { stats } = state;

        if (stats.connectedAt) {
            setElementState(dom.infoConnectedTime, formatDuration(Date.now() - stats.connectedAt), 'text-white');
        }

        // Helper to update stat with conditional highlighting
        const updateStat = (el, value, formatter = String) => {
            setElementState(el, formatter(value), value > 0 ? 'text-white' : 'text-neutral-500');
        };

        updateStat(dom.infoMessagesSent, stats.messagesSent);
        updateStat(dom.infoMessagesReceived, stats.messagesReceived);
        updateStat(dom.infoBytesSent, stats.bytesSent, formatBytes);
        updateStat(dom.infoBytesReceived, stats.bytesReceived, formatBytes);
    }

    function resetStatsUI() {
        resetElement(dom.infoConnectedTime);
        setElementState(dom.infoMessagesSent, '0');
        setElementState(dom.infoMessagesReceived, '0');
        setElementState(dom.infoBytesSent, '0 B');
        setElementState(dom.infoBytesReceived, '0 B');
    }

    function setConnectButtonState(connected) {
        const btn = dom.connectBtn;
        btn.textContent = connected ? 'Disconnect' : 'Connect';
        btn.className = connected
            ? 'w-full px-3 py-2 rounded text-sm font-semibold transition-all mt-1 bg-red-900/80 text-red-100 border border-red-900/80 hover:bg-red-900'
            : 'w-full px-3 py-2 rounded text-sm font-semibold transition-all mt-1 bg-white text-black border border-white hover:bg-neutral-200';
    }

    function updateConnectionUI(connected) {
        setConnectButtonState(connected);
        dom.sendBtn.disabled = !connected;
        dom.metadataAddBtn.disabled = !connected;
        setElementState(dom.statusConnection, connected ? 'Connected' : 'Disconnected', connected ? 'text-emerald-500' : 'text-neutral-500');

        if (!connected) {
            [dom.statusSession, dom.statusConnectionId, dom.statusOtherConnection].forEach(resetElement);
            resetStatsUI();
        }
    }

    function updateOtherConnectionUI(otherConnection) {
        if (otherConnection) {
            setElementState(dom.statusOtherConnection, otherConnection.id || otherConnection.connectionId || otherConnection, 'text-white');
        } else if (state.connected) {
            setElementState(dom.statusOtherConnection, 'Waiting...', 'text-amber-500');
        } else {
            resetElement(dom.statusOtherConnection);
        }
    }

    // ============================================================================
    // METADATA MANAGEMENT
    // ============================================================================
    function addMetadataEntry() {
        const key = dom.metadataKey.value.trim();
        const value = dom.metadataValue.value.trim();

        if (!key) {
            log('error', 'Metadata key is required');
            return;
        }

        state.metadataEntries.push({ key, value });
        dom.metadataKey.value = '';
        dom.metadataValue.value = '';
        dom.metadataKey.focus();
        renderMetadataList();
    }

    function removeMetadataEntry(index) {
        state.metadataEntries.splice(index, 1);
        renderMetadataList();
    }

    function renderMetadataList() {
        const container = dom.metadataList;

        if (state.metadataEntries.length === 0) {
            container.innerHTML = '';
            return;
        }

        container.innerHTML = state.metadataEntries.map((entry, index) => `
            <div class="flex items-center gap-2 px-2 py-1.5 bg-neutral-900/50 border border-neutral-800 rounded text-sm">
                <span class="text-neutral-400 truncate flex-1">${escapeHtml(entry.key)}</span>
                <span class="text-neutral-600">:</span>
                <span class="text-white truncate flex-1">${escapeHtml(entry.value)}</span>
                <button type="button" onclick="removeMetadataEntry(${index})"
                        class="text-neutral-500 hover:text-red-400 transition-colors px-1">x</button>
            </div>
        `).join('');
    }

    function escapeHtml(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    }

    function clearMetadataEntries() {
        state.metadataEntries = [];
        renderMetadataList();
        dom.messageMetadata.value = '';
    }

    function toggleMetadataMode() {
        const isJsonMode = dom.metadataJsonToggle.checked;
        dom.metadataKeyValueSection.classList.toggle('hidden', isJsonMode);
        dom.metadataJsonSection.classList.toggle('hidden', !isJsonMode);
    }

    function buildMetadataObject() {
        const isJsonMode = dom.metadataJsonToggle.checked;

        if (isJsonMode) {
            return parseJsonMetadata(dom.messageMetadata.value);
        }

        const obj = {};
        for (const entry of state.metadataEntries) {
            obj[entry.key] = entry.value;
        }
        return obj;
    }

    function parseJsonMetadata(metadataStr) {
        if (!metadataStr.trim()) return {};

        try {
            const parsed = JSON.parse(metadataStr);
            if (typeof parsed !== 'object' || parsed === null || Array.isArray(parsed)) {
                log('error', 'Metadata must be a JSON object');
                return null;
            }
            return parsed;
        } catch (e) {
            log('error', `Invalid metadata JSON: ${e.message}`);
            return null;
        }
    }

    // ============================================================================
    // VALIDATION
    // ============================================================================
    function getConnectionParams() {
        return {
            serverUrl: dom.serverUrl.value.trim(),
            sessionId: dom.sessionId.value.trim(),
            connectionId: dom.connectionId.value.trim(),
            secret: dom.secret.value.trim()
        };
    }

    function validateParams(params) {
        const { serverUrl, sessionId, connectionId, secret } = params;

        if (!serverUrl || !secret || !sessionId || !connectionId) {
            log('error', 'All fields are required');
            return false;
        }

        if (!CONFIG.SESSION_ID_PATTERN.test(sessionId)) {
            log('error', 'Session ID must be exactly 8 alphanumeric characters');
            return false;
        }

        return true;
    }

    // ============================================================================
    // MESSAGE BUILDING
    // ============================================================================
    function createMessage(type, payload) {
        return {
            header: {
                type,
                id: crypto.randomUUID(),
                timestamp: new Date().toISOString()
            },
            payload
        };
    }

    function createDataMessage(contentType, data, metadata) {
        return createMessage('data', { contentType, data, metadata });
    }

    function createAckMessage(messageId, size) {
        return createMessage('ack', { messageId, status: 'success', metadata: { receivedSize: size } });
    }

    // ============================================================================
    // MESSAGE HANDLERS
    // ============================================================================
    const messageHandlers = {
        ready(msg, payload) {
            log('ready', `Connected to session: ${payload.sessionId}`, null, msg);

            state.connected = true;
            state.stats.connectedAt = Date.now();
            state.timerId = setInterval(updateStatsUI, 1000);

            updateConnectionUI(true);
            updateStatsUI();

            if (payload.otherConnections && payload.otherConnections.length > 0) {
                state.otherConnection = payload.otherConnections[0];
                updateOtherConnectionUI(state.otherConnection);
                log('client', `Other connection already present: ${state.otherConnection.id}`);
            } else {
                log('client', 'Waiting for another connection to join...');
                updateOtherConnectionUI(null);
            }
        },

        connection(msg, payload) {
            const { status, connectionId } = payload;
            const isConnected = status === 'connected';

            log('connection', `Connection ${status}: ${connectionId}`, null, msg);
            state.otherConnection = isConnected ? { id: connectionId } : null;
            updateOtherConnectionUI(state.otherConnection);
        },

        data(msg, payload) {
            const contentType = payload.contentType || 'unknown';
            const size = payload.metadata?.size || payload.data?.length || 0;

            trackMessage('received', size);
            log('data', `Received: ${contentType} (${size} bytes)`, 'in', msg);

            // Send acknowledgment
            sendToServer(createAckMessage(msg.header?.id, size));
            log('ack', 'Sent acknowledgment', 'out');
        },

        ack(msg, payload) {
            log('ack', `Received: ${payload.status}`, 'in', msg);
        },

        error(msg, payload) {
            log('error', `[${payload.code}] ${payload.message}`, null, msg);
        }
    };

    function handleMessage(msg) {
        const payload = msg.payload || msg;
        const type = msg.header?.type || msg.type;
        const handler = messageHandlers[type];

        handler ? handler(msg, payload) : log('client', `Unknown message type: ${type}`, null, msg);
    }

    // ============================================================================
    // WEBSOCKET CONNECTION
    // ============================================================================
    function sendToServer(data) {
        if (state.ws?.readyState === WebSocket.OPEN) {
            state.ws.send(JSON.stringify(data));
        }
    }

    function buildWebSocketUrl({ serverUrl, sessionId, connectionId, secret }) {
        const params = new URLSearchParams({ sessionId, connectionId, secret });
        return `${serverUrl}/ws?${params}`;
    }

    function setupWebSocketHandlers(params) {
        const { ws } = state;

        ws.onopen = () => {
            log('client', 'WebSocket connected, waiting for READY message...');
            state.sessionId = params.sessionId;
            state.connectionId = params.connectionId;
            setElementState(dom.statusSession, params.sessionId, 'text-white');
            setElementState(dom.statusConnectionId, params.connectionId, 'text-white');
        };

        ws.onmessage = ({ data }) => {
            try {
                handleMessage(JSON.parse(data));
            } catch (e) {
                log('error', 'Failed to parse message', null, { error: e.message });
            }
        };

        ws.onerror = ({ type }) => log('error', `WebSocket error: ${type}`);

        ws.onclose = ({ code, reason }) => {
            const wasConnecting = !state.connected && state.sessionId;
            const message = reason || 'No reason provided';

            log(wasConnecting ? 'error' : 'client',
                `${wasConnecting ? 'Connection rejected' : 'Connection closed'} [${code}]: ${message}`);

            resetState();
            updateConnectionUI(false);
            state.ws = null;
        };
    }

    function connect() {
        const params = getConnectionParams();
        if (!validateParams(params)) return;

        log('client', `Connecting to ${params.serverUrl}...`);
        log('client', `Session: ${params.sessionId} | Connection: ${params.connectionId}`);

        try {
            state.ws = new WebSocket(buildWebSocketUrl(params));
            setupWebSocketHandlers(params);
        } catch (error) {
            log('error', `Failed to connect: ${error.message}`);
        }
    }

    function disconnect() {
        if (state.ws) {
            log('client', 'Disconnecting...');
            state.ws.close(CONFIG.WS_CLOSE_NORMAL, 'User disconnect');
        }
    }

    // ============================================================================
    // SEND MESSAGE
    // ============================================================================
    function sendMessage() {
        if (state.ws?.readyState !== WebSocket.OPEN) {
            log('error', 'Not connected');
            return;
        }

        const data = dom.messageData.value;
        if (!data.trim()) return;

        const userMetadata = buildMetadataObject();
        if (userMetadata === null) return;

        const contentType = dom.contentType.value;
        const messageSize = new Blob([data]).size;
        const message = createDataMessage(contentType === 'text' ? 'text' : 'binary', data, userMetadata);

        sendToServer(message);
        trackMessage('sent', messageSize);
        log('data', `Sent: ${contentType} (${messageSize} bytes)`, 'out');

        dom.messageData.value = '';
        clearMetadataEntries();
    }

    // ============================================================================
    // EVENT LISTENERS & INITIALIZATION
    // ============================================================================
    function clearConsole() {
        dom.console.innerHTML = '';
        log('client', 'Console cleared');
    }

    function initEventListeners() {
        dom.connectBtn.addEventListener('click', () => state.connected ? disconnect() : connect());
        dom.clearBtn.addEventListener('click', clearConsole);
        dom.sendBtn.addEventListener('click', sendMessage);
        dom.messageData.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // Metadata event listeners
        dom.metadataJsonToggle.addEventListener('change', toggleMetadataMode);
        dom.metadataAddBtn.addEventListener('click', addMetadataEntry);
        dom.metadataKey.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                if (dom.metadataKey.value.trim()) {
                    dom.metadataValue.focus();
                }
            }
        });
        dom.metadataValue.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                addMetadataEntry();
            }
        });

        // Connection form: Enter to connect
        const connectionInputs = [dom.serverUrl, dom.sessionId, dom.connectionId, dom.secret];
        connectionInputs.forEach((input) => {
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !state.connected) {
                    e.preventDefault();
                    connect();
                }
            });
        });
    }

    function init() {
        initEventListeners();
        log('client', 'CRSP Relay Playground initialized');
        log('client', 'Ready to connect');
    }

    // Expose function for inline onclick handlers
    window.removeMetadataEntry = removeMetadataEntry;

    init();
</script>
</body>
</html>
