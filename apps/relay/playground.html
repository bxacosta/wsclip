<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRSP Relay Playground</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        mono: ['JetBrains Mono', 'monospace']
                    }
                }
            }
        }
    </script>
    <style>
        :root { color-scheme: dark; }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden bg-black text-white font-mono antialiased">

<!-- TOP HEADER -->
<header class="h-12 border-b border-neutral-800 bg-black flex items-center justify-between px-6 shrink-0">
    <h1 class="text-sm font-bold tracking-wider">
        CRSP<span class="text-neutral-400">PLAYGROUND</span>
    </h1>
    <div class="text-xs text-neutral-400 uppercase tracking-wider">Content Relay Sync Protocol</div>
</header>

<!-- MAIN WORKSPACE -->
<div class="flex-1 flex overflow-hidden">

    <!-- LEFT SIDEBAR -->
    <aside class="w-96 bg-black border-r border-neutral-800 flex flex-col shrink-0 overflow-y-auto">

        <!-- Connection Section -->
        <section class="p-5 border-b border-neutral-800">
            <h2 class="text-xs text-neutral-400 uppercase tracking-wider mb-3 font-semibold">Connection</h2>
            <div class="space-y-2.5">
                <input id="serverUrl" type="text" value="ws://localhost:3000" placeholder="Server URL"
                       class="w-full px-3 py-2 bg-neutral-950 border border-neutral-800 rounded text-sm placeholder:text-neutral-500 focus:outline-none focus:border-neutral-700 focus:bg-neutral-900 transition-all">
                <input id="channelId" type="text" placeholder="Channel ID" maxlength="8" value="TEST1234"
                       class="w-full px-3 py-2 bg-neutral-950 border border-neutral-800 rounded text-sm placeholder:text-neutral-500 focus:outline-none focus:border-neutral-700 focus:bg-neutral-900 transition-all uppercase">
                <input id="peerId" type="text" placeholder="Peer ID" value="peer-1"
                       class="w-full px-3 py-2 bg-neutral-950 border border-neutral-800 rounded text-sm placeholder:text-neutral-500 focus:outline-none focus:border-neutral-700 focus:bg-neutral-900 transition-all">
                <input id="secret" type="text" placeholder="Secret" value="dev-secret-key-2025"
                       class="w-full px-3 py-2 bg-neutral-950 border border-neutral-800 rounded text-sm placeholder:text-neutral-500 focus:outline-none focus:border-neutral-700 focus:bg-neutral-900 transition-all">
                <button id="connectBtn"
                        class="w-full px-3 py-2 rounded text-sm font-semibold transition-all bg-white text-black border border-white hover:bg-neutral-200 mt-1">
                    Connect
                </button>
            </div>
        </section>

        <!-- Status Section -->
        <section class="p-5 border-b border-neutral-800">
            <h2 class="text-xs text-neutral-400 uppercase tracking-wider mb-3 font-semibold">Status</h2>
            <dl class="bg-neutral-950 border border-neutral-800 rounded p-3 space-y-2.5">
                <div class="flex items-center justify-between">
                    <dt class="text-neutral-300 text-sm">Connection</dt>
                    <dd id="statusConnection" class="font-medium text-neutral-500 text-sm">Disconnected</dd>
                </div>
                <div class="flex items-center justify-between">
                    <dt class="text-neutral-300 text-sm">Channel</dt>
                    <dd id="statusChannel" class="font-medium text-neutral-500 text-sm">-</dd>
                </div>
                <div class="flex items-center justify-between">
                    <dt class="text-neutral-300 text-sm">Peer ID</dt>
                    <dd id="statusPeerId" class="font-medium text-neutral-500 text-sm">-</dd>
                </div>
                <div class="flex items-center justify-between">
                    <dt class="text-neutral-300 text-sm">Peer</dt>
                    <dd id="statusPeer" class="font-medium text-neutral-500 text-sm">-</dd>
                </div>
            </dl>
        </section>

        <!-- Connection Info Section -->
        <section class="p-5 flex-1">
            <h2 class="text-xs text-neutral-400 uppercase tracking-wider mb-3 font-semibold">Connection Info</h2>
            <dl class="bg-neutral-950 border border-neutral-800 rounded p-3 space-y-3">
                <div class="flex items-center justify-between">
                    <dt class="text-neutral-400 text-sm">Connected</dt>
                    <dd id="infoConnectedTime" class="font-medium text-neutral-500 text-sm">-</dd>
                </div>
                <div class="flex items-center justify-between">
                    <dt class="text-neutral-400 text-sm">Messages Sent</dt>
                    <dd id="infoMessagesSent" class="font-medium text-neutral-500 text-sm">0</dd>
                </div>
                <div class="flex items-center justify-between">
                    <dt class="text-neutral-400 text-sm">Messages Received</dt>
                    <dd id="infoMessagesReceived" class="font-medium text-neutral-500 text-sm">0</dd>
                </div>
                <div class="flex items-center justify-between">
                    <dt class="text-neutral-400 text-sm">Bytes Sent</dt>
                    <dd id="infoBytesSent" class="font-medium text-neutral-500 text-sm">0 B</dd>
                </div>
                <div class="flex items-center justify-between">
                    <dt class="text-neutral-400 text-sm">Bytes Received</dt>
                    <dd id="infoBytesReceived" class="font-medium text-neutral-500 text-sm">0 B</dd>
                </div>
            </dl>
        </section>
    </aside>

    <!-- CENTER: Console -->
    <main class="flex-1 flex flex-col bg-neutral-950 min-w-0">
        <div class="h-10 border-b border-neutral-800 flex items-center justify-between px-5 bg-black">
            <h2 class="text-xs font-semibold text-neutral-400 uppercase tracking-wider">Console Output</h2>
            <div class="flex items-center gap-4">
                <label class="flex items-center gap-1.5 cursor-pointer">
                    <input id="autoscroll" type="checkbox" checked class="w-3 h-3 accent-white">
                    <span class="text-xs text-neutral-400">Autoscroll</span>
                </label>
                <button id="clearBtn" class="text-xs text-neutral-400 hover:text-white transition-colors uppercase tracking-wider">
                    Clear
                </button>
            </div>
        </div>
        <div id="console" class="flex-1 overflow-y-auto p-5 space-y-1.5 leading-tight select-text"></div>
    </main>

    <!-- RIGHT SIDEBAR -->
    <aside class="w-[448px] bg-black border-l border-neutral-800 flex flex-col shrink-0">
        <div class="p-5 flex-1 flex flex-col">
            <h2 class="text-xs text-neutral-400 uppercase tracking-wider mb-3 font-semibold">Send Message</h2>
            <div class="space-y-2.5 flex-1 flex flex-col">
                <select id="contentType"
                        class="w-full px-3 py-2 bg-neutral-950 border border-neutral-800 rounded text-sm focus:outline-none focus:border-neutral-700 cursor-pointer">
                    <option value="text">Text</option>
                    <option value="binary">Binary (base64)</option>
                </select>
                <textarea id="messageData" placeholder="Type a message... (Enter to send, Shift+Enter for new line)"
                          spellcheck="false"
                          class="flex-1 w-full px-3 py-2 bg-neutral-950 border border-neutral-800 rounded text-sm placeholder:text-neutral-500 focus:outline-none focus:border-neutral-700 focus:bg-neutral-900 transition-all resize-none leading-relaxed"></textarea>
                <button id="sendBtn" disabled
                        class="w-full px-3 py-2 rounded text-sm font-semibold transition-all bg-white text-black border border-white hover:bg-neutral-200 disabled:bg-neutral-800 disabled:text-neutral-500 disabled:border-neutral-800 disabled:cursor-not-allowed">
                    Send
                </button>
            </div>
        </div>
    </aside>
</div>

<script>
    // ============================================================================
    // CONFIGURATION
    // ============================================================================
    const CONFIG = {
        CHANNEL_ID_PATTERN: /^[a-zA-Z0-9]{8}$/,
        TIME_FORMAT: { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 },
        WS_CLOSE_NORMAL: 1000
    };

    // Badge styles using Tailwind classes only
    const BADGE_STYLES = {
        ready:   { bg: 'bg-blue-500/15',    text: 'text-blue-400',    border: 'border-blue-500/30' },
        peer:    { bg: 'bg-violet-500/15',  text: 'text-violet-400',  border: 'border-violet-500/30' },
        error:   { bg: 'bg-red-500/15',     text: 'text-red-400',     border: 'border-red-500/30' },
        data:    { bg: 'bg-green-500/15',   text: 'text-green-400',   border: 'border-green-500/30' },
        ack:     { bg: 'bg-teal-500/15',    text: 'text-teal-400',    border: 'border-teal-500/30' },
        control: { bg: 'bg-yellow-500/15',  text: 'text-yellow-400',  border: 'border-yellow-500/30' },
        client:  { bg: 'bg-neutral-500/15', text: 'text-neutral-400', border: 'border-neutral-500/30' }
    };

    // Direction indicators for log entries
    const DIRECTION_CONFIG = {
        in:     { symbol: '←', color: 'text-emerald-500' },
        out:    { symbol: '→', color: 'text-blue-500' },
        server: { symbol: '◆', color: 'text-violet-400' }
    };

    // Message types that come from server
    const SERVER_MESSAGE_TYPES = ['ready', 'peer', 'error'];

    // ============================================================================
    // DOM UTILITIES
    // ============================================================================
    const $ = (id) => document.getElementById(id);

    const dom = {
        serverUrl: $('serverUrl'),
        channelId: $('channelId'),
        peerId: $('peerId'),
        secret: $('secret'),
        connectBtn: $('connectBtn'),
        statusConnection: $('statusConnection'),
        statusChannel: $('statusChannel'),
        statusPeerId: $('statusPeerId'),
        statusPeer: $('statusPeer'),
        console: $('console'),
        autoscroll: $('autoscroll'),
        clearBtn: $('clearBtn'),
        infoConnectedTime: $('infoConnectedTime'),
        infoMessagesSent: $('infoMessagesSent'),
        infoMessagesReceived: $('infoMessagesReceived'),
        infoBytesSent: $('infoBytesSent'),
        infoBytesReceived: $('infoBytesReceived'),
        contentType: $('contentType'),
        messageData: $('messageData'),
        sendBtn: $('sendBtn')
    };

    /** Updates element text and color in one call */
    function setElementState(el, text, colorClass = 'text-neutral-500') {
        el.textContent = text;
        el.className = `font-medium text-sm ${colorClass}`;
    }

    /** Resets element to default empty state */
    function resetElement(el) {
        setElementState(el, '-');
    }

    // ============================================================================
    // FORMAT UTILITIES
    // ============================================================================
    function formatBytes(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return `${parseFloat((bytes / k ** i).toFixed(1))} ${sizes[i]}`;
    }

    function formatDuration(ms) {
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);

        if (hours > 0) return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
        if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
        return `${seconds}s`;
    }

    function formatTimestamp() {
        return new Date().toLocaleTimeString('en-US', CONFIG.TIME_FORMAT);
    }

    // ============================================================================
    // STATE MANAGEMENT
    // ============================================================================
    const state = {
        ws: null,
        connected: false,
        channelId: null,
        peerId: null,
        peer: null,
        stats: createEmptyStats(),
        timerId: null
    };

    function createEmptyStats() {
        return {
            connectedAt: null,
            messagesSent: 0,
            messagesReceived: 0,
            bytesSent: 0,
            bytesReceived: 0
        };
    }

    function resetState() {
        Object.assign(state, {
            connected: false,
            channelId: null,
            peerId: null,
            peer: null,
            stats: createEmptyStats()
        });

        if (state.timerId) {
            clearInterval(state.timerId);
            state.timerId = null;
        }
    }

    function trackMessage(direction, bytes) {
        if (direction === 'sent') {
            state.stats.messagesSent++;
            state.stats.bytesSent += bytes;
        } else {
            state.stats.messagesReceived++;
            state.stats.bytesReceived += bytes;
        }
        updateStatsUI();
    }

    // ============================================================================
    // LOGGING SYSTEM
    // ============================================================================
    function createLogBadge(type) {
        const style = BADGE_STYLES[type] || BADGE_STYLES.client;
        const span = document.createElement('span');
        span.className = `inline-flex items-center px-1.5 py-0.5 rounded text-[10px] font-semibold uppercase tracking-wide border ${style.bg} ${style.text} ${style.border}`;
        span.textContent = type.toUpperCase();
        return span;
    }

    function createDirectionIndicator(direction, type) {
        const span = document.createElement('span');
        span.className = 'w-4 text-center shrink-0';

        const dirKey = direction || (SERVER_MESSAGE_TYPES.includes(type) ? 'server' : null);
        const config = DIRECTION_CONFIG[dirKey];

        if (config) {
            span.className += ` ${config.color}`;
            span.textContent = config.symbol;
        }

        return span;
    }

    function createLogEntry(type, message, direction, data) {
        const entry = document.createElement('div');
        entry.className = 'hover:bg-neutral-900/50 -mx-2 px-2 py-1 rounded transition-colors';

        // Main row
        const row = document.createElement('div');
        row.className = 'flex items-start gap-2';

        // Timestamp
        const timestamp = document.createElement('span');
        timestamp.className = 'text-neutral-500 text-xs shrink-0 pt-0.5 tabular-nums';
        timestamp.textContent = `[${formatTimestamp()}]`;

        // Message text
        const msg = document.createElement('span');
        msg.className = 'text-neutral-300 text-sm flex-1';
        msg.textContent = message;

        row.append(timestamp, createDirectionIndicator(direction, type), createLogBadge(type), msg);
        entry.appendChild(row);

        // Optional data payload
        if (data) {
            const dataDiv = document.createElement('div');
            dataDiv.className = 'ml-32 text-xs text-neutral-500 bg-neutral-900/50 border border-neutral-800 rounded p-2 mt-1 font-mono overflow-x-auto whitespace-pre';
            dataDiv.textContent = JSON.stringify(data, null, 2);
            entry.appendChild(dataDiv);
        }

        return entry;
    }

    function log(type, message, direction = null, data = null) {
        dom.console.appendChild(createLogEntry(type, message, direction, data));

        if (dom.autoscroll.checked) {
            dom.console.scrollTop = dom.console.scrollHeight;
        }
    }

    // ============================================================================
    // UI UPDATE FUNCTIONS
    // ============================================================================
    function updateStatsUI() {
        const { stats } = state;

        if (stats.connectedAt) {
            setElementState(dom.infoConnectedTime, formatDuration(Date.now() - stats.connectedAt), 'text-white');
        }

        // Helper to update stat with conditional highlighting
        const updateStat = (el, value, formatter = String) => {
            setElementState(el, formatter(value), value > 0 ? 'text-white' : 'text-neutral-500');
        };

        updateStat(dom.infoMessagesSent, stats.messagesSent);
        updateStat(dom.infoMessagesReceived, stats.messagesReceived);
        updateStat(dom.infoBytesSent, stats.bytesSent, formatBytes);
        updateStat(dom.infoBytesReceived, stats.bytesReceived, formatBytes);
    }

    function resetStatsUI() {
        resetElement(dom.infoConnectedTime);
        setElementState(dom.infoMessagesSent, '0');
        setElementState(dom.infoMessagesReceived, '0');
        setElementState(dom.infoBytesSent, '0 B');
        setElementState(dom.infoBytesReceived, '0 B');
    }

    function setConnectButtonState(connected) {
        const btn = dom.connectBtn;
        btn.textContent = connected ? 'Disconnect' : 'Connect';
        btn.className = connected
            ? 'w-full px-3 py-2 rounded text-sm font-semibold transition-all mt-1 bg-red-900/80 text-red-100 border border-red-900/80 hover:bg-red-900'
            : 'w-full px-3 py-2 rounded text-sm font-semibold transition-all mt-1 bg-white text-black border border-white hover:bg-neutral-200';
    }

    function updateConnectionUI(connected) {
        setConnectButtonState(connected);
        dom.sendBtn.disabled = !connected;
        setElementState(dom.statusConnection, connected ? 'Connected' : 'Disconnected', connected ? 'text-emerald-500' : 'text-neutral-500');

        if (!connected) {
            [dom.statusChannel, dom.statusPeerId, dom.statusPeer].forEach(resetElement);
            resetStatsUI();
        }
    }

    function updatePeerUI(peer) {
        if (peer) {
            setElementState(dom.statusPeer, peer.id || peer.peerId || peer, 'text-white');
        } else if (state.connected) {
            setElementState(dom.statusPeer, 'Waiting...', 'text-amber-500');
        } else {
            resetElement(dom.statusPeer);
        }
    }

    // ============================================================================
    // VALIDATION
    // ============================================================================
    function getConnectionParams() {
        return {
            serverUrl: dom.serverUrl.value.trim(),
            channelId: dom.channelId.value.trim(),
            peerId: dom.peerId.value.trim(),
            secret: dom.secret.value.trim()
        };
    }

    function validateParams(params) {
        const { serverUrl, channelId, peerId, secret } = params;

        if (!serverUrl || !secret || !channelId || !peerId) {
            log('error', 'All fields are required');
            return false;
        }

        if (!CONFIG.CHANNEL_ID_PATTERN.test(channelId)) {
            log('error', 'Channel ID must be exactly 8 alphanumeric characters');
            return false;
        }

        return true;
    }

    // ============================================================================
    // MESSAGE BUILDING
    // ============================================================================
    function createMessage(type, payload) {
        return {
            header: {
                type,
                id: crypto.randomUUID(),
                timestamp: new Date().toISOString()
            },
            payload
        };
    }

    function createDataMessage(contentType, data, size) {
        return createMessage('data', { contentType, data, metadata: { size } });
    }

    function createAckMessage(messageId, size) {
        return createMessage('ack', { messageId, status: 'success', metadata: { receivedSize: size } });
    }

    // ============================================================================
    // MESSAGE HANDLERS
    // ============================================================================
    const messageHandlers = {
        ready(msg, payload) {
            log('ready', `Connected to channel: ${payload.channelId}`, null, msg);

            state.connected = true;
            state.stats.connectedAt = Date.now();
            state.timerId = setInterval(updateStatsUI, 1000);

            updateConnectionUI(true);
            updateStatsUI();

            if (payload.peer) {
                state.peer = payload.peer;
                updatePeerUI(payload.peer);
                log('client', `Peer already connected: ${payload.peer.id}`);
            } else {
                log('client', 'Waiting for peer to join...');
                updatePeerUI(null);
            }
        },

        peer(msg, payload) {
            const { event, peerId } = payload;
            const isJoin = event === 'joined';

            log('peer', `Peer ${event}: ${peerId}`, null, msg);
            state.peer = isJoin ? { peerId } : null;
            updatePeerUI(state.peer);
        },

        data(msg, payload) {
            const contentType = payload.contentType || 'unknown';
            const size = payload.metadata?.size || payload.data?.length || 0;

            trackMessage('received', size);
            log('data', `Received: ${contentType} (${size} bytes)`, 'in', msg);

            // Send acknowledgment
            sendToServer(createAckMessage(msg.header?.id, size));
            log('ack', 'Sent acknowledgment', 'out');
        },

        ack(msg, payload) {
            log('ack', `Received: ${payload.status}`, 'in', msg);
        },

        error(msg, payload) {
            log('error', `[${payload.code}] ${payload.message}`, null, msg);
        }
    };

    function handleMessage(msg) {
        const payload = msg.payload || msg;
        const type = msg.header?.type || msg.type;
        const handler = messageHandlers[type];

        handler ? handler(msg, payload) : log('client', `Unknown message type: ${type}`, null, msg);
    }

    // ============================================================================
    // WEBSOCKET CONNECTION
    // ============================================================================
    function sendToServer(data) {
        if (state.ws?.readyState === WebSocket.OPEN) {
            state.ws.send(JSON.stringify(data));
        }
    }

    function buildWebSocketUrl({ serverUrl, channelId, peerId, secret }) {
        const params = new URLSearchParams({ channelId, peerId, secret });
        return `${serverUrl}/ws?${params}`;
    }

    function setupWebSocketHandlers(params) {
        const { ws } = state;

        ws.onopen = () => {
            log('client', 'WebSocket connected, waiting for READY message...');
            state.channelId = params.channelId;
            state.peerId = params.peerId;
            setElementState(dom.statusChannel, params.channelId, 'text-white');
            setElementState(dom.statusPeerId, params.peerId, 'text-white');
        };

        ws.onmessage = ({ data }) => {
            try {
                handleMessage(JSON.parse(data));
            } catch (e) {
                log('error', 'Failed to parse message', null, { error: e.message });
            }
        };

        ws.onerror = ({ type }) => log('error', `WebSocket error: ${type}`);

        ws.onclose = ({ code, reason }) => {
            const wasConnecting = !state.connected && state.channelId;
            const message = reason || 'No reason provided';

            log(wasConnecting ? 'error' : 'client',
                `${wasConnecting ? 'Connection rejected' : 'Connection closed'} [${code}]: ${message}`);

            resetState();
            updateConnectionUI(false);
            state.ws = null;
        };
    }

    function connect() {
        const params = getConnectionParams();
        if (!validateParams(params)) return;

        log('client', `Connecting to ${params.serverUrl}...`);
        log('client', `Channel: ${params.channelId} | Peer: ${params.peerId}`);

        try {
            state.ws = new WebSocket(buildWebSocketUrl(params));
            setupWebSocketHandlers(params);
        } catch (error) {
            log('error', `Failed to connect: ${error.message}`);
        }
    }

    function disconnect() {
        if (state.ws) {
            log('client', 'Disconnecting...');
            state.ws.close(CONFIG.WS_CLOSE_NORMAL, 'User disconnect');
        }
    }

    // ============================================================================
    // SEND MESSAGE
    // ============================================================================
    function sendMessage() {
        if (state.ws?.readyState !== WebSocket.OPEN) {
            log('error', 'Not connected');
            return;
        }

        const data = dom.messageData.value;
        if (!data.trim()) return;

        const contentType = dom.contentType.value;
        const messageSize = new Blob([data]).size;
        const message = createDataMessage(contentType === 'text' ? 'text' : 'binary', data, messageSize);

        sendToServer(message);
        trackMessage('sent', messageSize);
        log('data', `Sent: ${contentType} (${messageSize} bytes)`, 'out');

        dom.messageData.value = '';
    }

    // ============================================================================
    // EVENT LISTENERS & INITIALIZATION
    // ============================================================================
    function clearConsole() {
        dom.console.innerHTML = '';
        log('client', 'Console cleared');
    }

    function initEventListeners() {
        dom.connectBtn.addEventListener('click', () => state.connected ? disconnect() : connect());
        dom.clearBtn.addEventListener('click', clearConsole);
        dom.sendBtn.addEventListener('click', sendMessage);
        dom.messageData.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
    }

    function init() {
        initEventListeners();
        log('client', 'CRSP Relay Playground initialized');
        log('client', 'Ready to connect');
    }

    init();
</script>
</body>
</html>